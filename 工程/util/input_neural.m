%接上一个input_neural文件
%总规则为从左到右，从上到下

%first layer
%输入为copy形式输入，且为单通道
%neural空白处为其左边相邻的copy，默认制造2份copy
%每个core上的weight排列(连接关系)都是一样的,因为是权值共享
%一共使用9个core，每个core输入为12*12*1*2，每个core输出为8*8*8*2
%权值配置地址
for c=1:9
    for k=1:8
        for j=1:8
            for i=1:8
                for s=1:5
                    layer1_neural{c}{(k-1)*64*2+(j-1)*8*2+(i-1)*2+1}(s,:)=(12*2*(j+s-2)+2*(i-1)+1):(12*2*(j+s-2)+2*(i-1)+1+9);
                end
            end
        end
    end
end

%路由地址
%第一层卷积后得到9个8*8*8*2，分别分布在9个core的输出上，
%可以直接路由到下一层对应的9个core上进行conv-pool运算，且为一一对应，按顺序排列



%second layer
%输入为copy形式输入，且为8通道
%neural空白处为其左边相邻的copy，默认制造2份copy
%一共使用9个core，每个core的输入为8*8*8*2，每个core输出为4*4*8*(2,4,8)
%权值配置地址
for c=1:9
    for k=1:8   %输出特征图的数量
        for l=1:8   %输入特征图的数量
            for j=1:4
                for i=1:4
                    for s=1:2
                        if c==1||c==3||c==7||c==9
                           layer2_neural{c}{(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                        else
                            if c==2||c==4||c==6||c==8
                              layer2_neural{c}{(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                              layer2_neural{c}{256+(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                            else 
                              layer2_neural{c}{(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                              layer2_neural{c}{256+(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                              layer2_neural{c}{512+(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                              layer2_neural{c}{768+(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1):(8*8*2*(l-1)+8*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                            end
                        end
                    end
                end
            end
        end
    end
end


%路由地址
%，下一层1个core上的输入来自于上一层4个core上的输出，分别为(1,2,4,5),(2,3,5,6),(4,5,7,8),(5,6,8,9),
%按上一层的输出排列来看,只需要在输出core按顺序各自分块，直接路由到对应的输入core上即可，
%输出core上已经做好大的分块，但需要注意每4个core输出到1个core输入的内部路由顺序

%third layer
%输入为copy形式输入，且为8通道
%neural空白处为其左边相邻的copy，默认制造2份copy
%一共使用4个core，每个core输入为8*8*8*2，每个core输出为4*4*32*2

%权值配置地址
for c=1:4
    for k=1:32
        for l=1:8
            for j=1:4
                for i=1:4
                    for s=1:5
                        layer3_neural{c}{(k-1)*16*2+(j-1)*4*2+(i-1)*2+1}(s,:,l)=(8*8*2*(l-1)+8*2*(j+s-2)+2*(i-1)+1):(8*8*2*(l-1)+8*2*(j+s-2)+2*(i-1)+1+9);
                    end
                end
            end
        end
    end
end


%路由地址
%上一层每一个core上的输出均为4*4*32，一共有4个这样的输出core，
%，输出也是按照从左到右，从上到下的顺序排列，故可以直接按顺序路由到下一层对应的输入core上

%forth layer
%输入为copy形式输入，且为32通道
%neural空白处为其左边相邻的copy，默认制造2份copy
%一共使用4个core，每个core输入为4*4*32*2，每个core输出为2*2*32*(1,2,4,8)
for c=1:4
    for k=1:32
        for l=1:32
            for j=1:2
                for i=1:2
                    for s=1:2
                        layer4_neural{c}{(k-1)*4*2+(j-1)*2*2+(i-1)*2+1}(s,:,l)=(4*4*2*(l-1)+4*2*((j-1)*2+s-1)+2*(i-1)*2+1):(4*4*2*(l-1)+4*2*((j-1)*2+s-1)+2*(i-1)*2+1+3);
                    end
                end
            end
        end
    end
end


%路由地址
%按接下来进行要进行的操作，酌情进行copy制造，如若离线进行后续操作，可以不制造copy

%全连接或者继续卷积













